from aiogram import Bot, Dispatcher, executor, types
from aiogram.types import KeyboardButton, ReplyKeyboardMarkup
import random


bot = Bot(token="6363883120:AAEmZjTdFh_Z8i51ofol2spD9NKXojPscQ0")
dp = Dispatcher(bot)

bd = {}  # Глобальная база данных (хранит в себе user_id, вопрос и ответ)


async def new_randon_primer(message: types.Message):  # Создаёт новый пример, записывает в базу данных, отпрявляет вопрос

    ################################
    # Блок создания примера и ответа
    a = random.randint(1, 10)
    b = random.randint(1, 10)
    c = str(a + b)
    str_qst = f"{a} + {b} = ?"
    ################################

    ################################
    # Запись в бд:
    # ключ - user_id
    # значение - массив с вопросом и ответом
    bd[message.from_user.id] = [str_qst, c]
    ################################

    ################################
    # Блок создания массива с ответами
    mas = []
    for _ in range(3):
        time_value = str(random.randint(1, 20))  # Временная переменная с рандомным ответом
        while time_value in mas:  # Если уже есть такой ответ -> придумываем новый
            time_value = str(random.randint(1, 20))
        mas.append(time_value)  # В первые три ячейки кладем рандомные ответы
    mas.append(c)  # В четвёртой лежит верный ответ
    random.shuffle(mas)  # Перемешиваем
    ################################

    ################################
    # Блок создания клавиатуры
    btns = [  # Если создавать клаву таким образом, то она будет выглядеть круче (так, как ты сам расположишь кнопки)
        [KeyboardButton(mas[0]), KeyboardButton(mas[1])],
        [KeyboardButton(mas[2]), KeyboardButton(mas[3])]
    ]
    keyboard = ReplyKeyboardMarkup(resize_keyboard=True, keyboard=btns)
    ################################

    ################################
    # Отправляем вопрос и варианты ответов
    await message.answer(text=str_qst, reply_markup=keyboard)
    ################################


@dp.message_handler()  # Оставляем вход пустым, чтоб бот реагировал на все сообщения
async def msg(message: types.Message):
    if message.from_user.id in bd:  # Если пользователь в бд, значит мы уже задавали вопрос и знаем ответ
        if message.text == bd[message.from_user.id][1]:  # Если сообщение, которое написал пользователь, равно правильному ответу
            await new_randon_primer(message)  # То мы задаем новые вопрос
        else:  # Если сообщение, которое написал пользователь, не является верным ответом
            await message.reply(f"Упс, этот ответ неверный, попробуй заново:\n{bd[message.from_user.id][0]}")  # То мы просим отвить заново
    else:  # Если пользователя нет в бд, значит он только начал пользоваться ботом -> задаём первый вопрос
        await new_randon_primer(message)

    # Как итог, пользователь отвечает буквально 'while True', любое его сообщение будет расценено как верно/неверно


if __name__ == '__main__':
    executor.start_polling(dispatcher=dp, skip_updates=True)
